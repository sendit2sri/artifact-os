# Project Context & Rules

## Technical Stack
- **Languages:** Python 3.10+, TypeScript (Frontend).
- **Backend:** FastAPI, SQLAlchemy (PostgreSQL), Alembic migrations.
- **Tools:** Docker, Syncthing (sync-friendly folder structures), Obsidian (for documentation).

## Context Management (Anti-Bloat)
- **Conciseness:** Be brief. Avoid long explanations of code I didn't ask for.
- **File Awareness:** Only read files explicitly mentioned or directly related to the task.
- **No Refactoring:** Do not refactor code outside the immediate scope unless asked.
- **Sync Safety:** Avoid creating deep, complex folder structures that might trigger Syncthing conflicts.

## Python Coding Standards
- Use type hints for all function signatures.
- Prefer `pydantic` for data validation (match existing project schemas).
- Ensure all API endpoints include proper error handling and status codes.

## Agent Behavior
- **Role:** Act as a Principal Software Architect.
- **Strategy:** If a task is complex, outline the steps *before* writing code.
- **Failures:** If you encounter a rate limit or "context full" error, warn me immediately and suggest starting a new chat.

## Documentation (Obsidian-first)
- If I ask to document something, format it for **Obsidian** (Markdown with Wikilinks `[[Like This]]`).
- **No root docs:** Any new documentation MUST be written under `docs/**` and SHOULD update `docs/_index.md`. Never create `.md` files in repo root except `README.md` and `QUICK_START.md`.

### Docs generator rules (always-on)
- When I say: “document this”, “write docs”, “create summary”, “generate .md”, or similar:
  1) Create one or more `.md` files under `docs/**` (choose the correct bucket).
  2) Use the same structure every time:
     - `# <Title>`
     - `## Summary`
     - `## Context`
     - `## What changed`
     - `## How to run / verify`
     - `## Files touched`
     - `## Links` (Obsidian wikilinks)
  3) Add/Update links in `docs/_index.md` so the new docs are discoverable.
  4) Output the final file paths as Obsidian-friendly links (e.g., `[[testing/e2e/E2E_FINAL_SUMMARY]]`).

### Docs buckets (use these paths)
- `docs/testing/e2e/` — Playwright/E2E
- `docs/changes/YYYY/MM/` — dated change notes
- `docs/features/` — feature behavior + UX notes
- `docs/architecture/` — design/structure decisions
- `docs/solutions/` — fixes + runbooks
- `docs/routing/` — routing/API integration notes
- `docs/release/` — release notes
- `docs/misc/` — everything else

## Change Control
- **No breaking changes:** Do not change API contracts, DB schemas, or response formats unless explicitly asked.
- **Assumptions:** If key requirements are missing, ask 1 concise question or proceed with clearly stated assumptions.

## File & Scope Boundaries
- **Allowed reads:** You may read direct dependencies imported by the file being edited when necessary.
- **Allowed writes:** Only modify files I mention + minimal additional files required for the same change (e.g., tests/migrations/docs). List all files you will touch before editing.

## Backend Conventions (FastAPI/SQLAlchemy)
- Do not mix async/sync DB patterns. Follow the existing project pattern.
- Use the project’s DB session dependency and transaction conventions.
- Any schema change requires an Alembic migration with upgrade/downgrade steps.

## Quality Bar
- New/changed endpoints must include: request/response schemas, correct status codes, and at least one test.
- Do not add new dependencies unless asked; if unavoidable, explain why and keep it minimal.

## Security Defaults
- Never log secrets or sensitive data. Use env vars for secrets.
- If new config is added, update `.env.example` and document it briefly.

## Output Format
- When delivering changes, include:
  1) Files changed/added
  2) Code (patch or per-file sections)
  3) Commands to run (tests/migrations)